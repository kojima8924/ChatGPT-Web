<!doctype html>
<html lang="ja">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Text Autocomplete Demo (OpenAI API)</title>
    <style>
        :root {
            --bg: #0b0f19;
            --panel: #111827;
            --panel2: #0f172a;
            --border: rgba(255,255,255,.12);
            --text: rgba(255,255,255,.92);
            --muted: rgba(255,255,255,.68);
            --ghost: rgba(255,255,255,.35);
            --accent: #60a5fa;
            --danger: #fb7185;
            --ok: #34d399;
            --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
            --sans: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Hiragino Kaku Gothic ProN", "Noto Sans JP", "Yu Gothic", "Meiryo", sans-serif;
        }
        html, body { height: 100%; }
        body {
            margin: 0;
            font-family: var(--sans);
            background: radial-gradient(1200px 600px at 30% -10%, #1f2a5a 0%, transparent 60%),
                        radial-gradient(800px 500px at 80% 0%, #10304a 0%, transparent 55%),
                        var(--bg);
            color: var(--text);
        }
        .wrap {
            max-width: 980px;
            margin: 22px auto 40px;
            padding: 0 16px;
        }
        h1 {
            font-size: 18px;
            margin: 0 0 14px;
            font-weight: 700;
            letter-spacing: .2px;
        }
        .card {
            border: 1px solid var(--border);
            background: linear-gradient(180deg, rgba(17,24,39,.92), rgba(15,23,42,.92));
            border-radius: 14px;
            box-shadow: 0 20px 60px rgba(0,0,0,.35);
            overflow: hidden;
            margin-bottom: 14px;
        }
        .card .head {
            padding: 14px 14px 10px;
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            gap: 10px;
            justify-content: space-between;
            flex-wrap: wrap;
        }
        .left, .right {
            display: flex;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap;
        }
        .label {
            font-size: 12px;
            color: var(--muted);
        }
        .seg {
            display: inline-flex;
            border: 1px solid var(--border);
            border-radius: 999px;
            overflow: hidden;
            background: rgba(255,255,255,.04);
        }
        .seg button {
            appearance: none;
            border: 0;
            padding: 8px 10px;
            cursor: pointer;
            color: var(--muted);
            background: transparent;
            font-size: 12px;
            font-family: var(--mono);
        }
        .seg button.active {
            background: rgba(96,165,250,.18);
            color: rgba(255,255,255,.95);
        }
        .seg button:hover { background: rgba(255,255,255,.06); }

        input[type="password"], input[type="text"]{
            border: 1px solid var(--border);
            background: rgba(0,0,0,.18);
            color: rgba(255,255,255,.92);
            padding: 9px 10px;
            border-radius: 10px;
            outline: none;
            font-size: 12px;
            font-family: var(--mono);
            width: min(380px, 70vw);
        }
        .mini {
            width: 200px;
        }
        .btn {
            border: 1px solid var(--border);
            background: rgba(255,255,255,.06);
            color: rgba(255,255,255,.9);
            padding: 9px 10px;
            border-radius: 10px;
            cursor: pointer;
            font-size: 12px;
        }
        .btn:hover { background: rgba(255,255,255,.09); }
        .btn.danger:hover { background: rgba(251,113,133,.14); border-color: rgba(251,113,133,.3); }
        .status {
            font-size: 12px;
            color: var(--muted);
            font-family: var(--mono);
        }
        .dot { display: inline-block; width: 8px; height: 8px; border-radius: 99px; margin-right: 8px; vertical-align: -1px; background: rgba(255,255,255,.25); }
        .dot.ok { background: rgba(52,211,153,.9); }
        .dot.bad { background: rgba(251,113,133,.95); }
        .dot.busy { background: rgba(96,165,250,.95); }

        .editor {
            position: relative;
            padding: 14px;
        }
        .editorShell{
            position: relative;
            border: 1px solid var(--border);
            background: rgba(0,0,0,.14);
            border-radius: 14px;
            overflow: hidden;
            min-height: 320px;
        }
        /* Mirror layer (shows typed + ghost) */
        pre#mirror {
            margin: 0;
            padding: 14px;
            min-height: 320px;
            white-space: pre-wrap;
            word-wrap: break-word;
            font-family: var(--mono);
            font-size: 14px;
            line-height: 1.6;
            color: rgba(255,255,255,.92);
            pointer-events: none;
        }
        #mirror .ghost { color: var(--ghost); }

        /* Real textarea layer (transparent text, caret visible) */
        textarea#ta {
            position: absolute;
            inset: 0;
            resize: none;
            border: 0;
            outline: none;
            padding: 14px;
            width: 100%;
            height: 100%;
            background: transparent;
            color: transparent;          /* important: mirror displays text */
            caret-color: rgba(255,255,255,.92);
            font-family: var(--mono);
            font-size: 14px;
            line-height: 1.6;
        }
        /* selection still works but text is transparent; this is demo-friendly */
        textarea#ta::selection { background: rgba(96,165,250,.35); }

        .foot {
            padding: 14px 14px 16px;
            border-top: 1px solid var(--border);
            background: rgba(255,255,255,.02);
            color: var(--muted);
            font-size: 13px;
            line-height: 1.7;
        }
        .foot kbd{
            font-family: var(--mono);
            font-size: 12px;
            border: 1px solid var(--border);
            background: rgba(255,255,255,.06);
            border-bottom-color: rgba(255,255,255,.12);
            padding: 2px 6px;
            border-radius: 8px;
            color: rgba(255,255,255,.86);
        }
        .small {
            font-size: 12px;
            color: var(--muted);
        }
        a { color: rgba(96,165,250,.95); }
    </style>
</head>
<body>
    <div class="wrap">
        <h1>Text Autocomplete Demo (front-only / single file)</h1>

        <!-- Top: model tabs + API key -->
        <div class="card">
            <div class="head">
                <div class="left">
                    <div>
                        <div class="label">Model (tabs)</div>
                        <div class="seg" id="modelTabs" role="tablist" aria-label="Model tabs">
                            <button type="button" class="active" data-model="gpt-4o-mini">gpt-4o-mini</button>
                            <button type="button" data-model="gpt-4.1-mini">gpt-4.1-mini</button>
                            <button type="button" data-model="gpt-5-mini">gpt-5-mini</button>
                            <button type="button" data-model="gpt-5.2">gpt-5.2</button>
                        </div>
                    </div>
                    <div>
                        <div class="label">Custom model (optional)</div>
                        <input id="customModel" class="mini" type="text" placeholder="e.g. gpt-4o" spellcheck="false" />
                    </div>
                </div>

                <div class="right">
                    <div>
                        <div class="label">OpenAI API Key (saved to Web Storage)</div>
                        <input id="apiKey" type="password" placeholder="sk-..." autocomplete="off" spellcheck="false" />
                    </div>
                    <button class="btn" id="saveKeyBtn" type="button">Save</button>
                    <button class="btn danger" id="clearKeyBtn" type="button">Clear</button>
                    <div class="status" id="status"><span class="dot"></span>idle</div>
                </div>
            </div>

            <!-- Middle: text input with ghost completion -->
            <div class="editor">
                <div class="editorShell" aria-label="Editor">
                    <pre id="mirror"></pre>
                    <textarea id="ta" spellcheck="false" aria-label="Text input"></textarea>
                </div>
                <div class="small" style="margin-top:10px;">
                    ※「入力文字はミラー層に描画、textareaの文字色は透明（カーソルだけ表示）」方式です。
                </div>
            </div>

            <!-- Bottom: usage -->
            <div class="foot">
                <div><strong>使い方</strong></div>
                <ul style="margin:8px 0 0; padding-left: 18px;">
                    <li>テキスト欄の入力が <kbd>700ms</kbd> 止まると、続きが <span style="color:var(--ghost);">灰色</span> で表示されます。</li>
                    <li><kbd>Tab</kbd>：灰色部分を全部確定（追記）</li>
                    <li><kbd>→</kbd>：灰色部分を1文字確定 / <kbd>←</kbd>：1文字戻す（カーソルが末尾にあるときのみ）</li>
                    <li><kbd>Enter</kbd>：灰色部分を削除（提案を破棄）※提案が無いときは普通に改行</li>
                    <li><kbd>Esc</kbd>：灰色部分を削除（提案を破棄）</li>
                </ul>
            </div>
        </div>
    </div>

    <script>
        // ====== Settings ======
        const STORAGE_KEY = "demo_openai_api_key_v1"; // localStorage key
        const DEBOUNCE_MS = 700;
        const MAX_CONTEXT_CHARS = 2000;
        const MAX_OUTPUT_TOKENS = 96;      // small completion
        const TEMPERATURE = 0.7;
        const DEBUG_CONSOLE = true;      // ここを false にするとログ停止
        const LOG_TRIM = 800;            // 入出力テキストを最大何文字ログするか
        const LOG_RESPONSE_JSON = false; // trueでレスポンスJSON全部出す


        // ====== DOM ======
        const modelTabs = document.getElementById("modelTabs");
        const customModel = document.getElementById("customModel");
        const apiKeyEl = document.getElementById("apiKey");
        const saveKeyBtn = document.getElementById("saveKeyBtn");
        const clearKeyBtn = document.getElementById("clearKeyBtn");
        const statusEl = document.getElementById("status");
        const mirrorEl = document.getElementById("mirror");
        const ta = document.getElementById("ta");

        // ====== State ======
        let selectedModel = "gpt-4o-mini";
        let ghost = "";
        let debounceTimer = null;
        let inFlight = null; // AbortController
        let lastRequestedPrefix = ""; // to avoid applying stale results

        // ====== Helpers ======
        function maskApiKey(k) {
            if (!k) return "";
            // 先頭4文字だけ残してマスク
            const head = k.slice(0, 4);
            return head + "…" + "*".repeat(Math.max(0, k.length - 5));
        }

        function trimForLog(s, n = LOG_TRIM) {
            if (typeof s !== "string") return s;
            if (s.length <= n) return s;
            return s.slice(0, n) + `…(trimmed ${s.length - n} chars)`;
        }

        function logGroup(title, obj) {
            if (!DEBUG_CONSOLE) return;
            console.groupCollapsed(title);
            try { console.log(obj); } finally { console.groupEnd(); }
        }

        function setStatus(kind, text) {
            const dot = statusEl.querySelector(".dot");
            dot.className = "dot" + (kind ? (" " + kind) : "");
            statusEl.lastChild && statusEl.lastChild.remove();
            statusEl.appendChild(document.createTextNode(text));
        }

        function escapeHtml(s) {
            return s.replace(/[&<>"']/g, (c) => (
                c === "&" ? "&amp;" :
                c === "<" ? "&lt;" :
                c === ">" ? "&gt;" :
                c === '"' ? "&quot;" : "&#39;"
            ));
        }

        function render() {
            const text = ta.value || "";
            // Keep trailing newline visible in <pre>
            const safeText = escapeHtml(text).replace(/\n$/g, "\n\u200b");
            const safeGhost = escapeHtml(ghost);
            mirrorEl.innerHTML = safeText + (ghost ? `<span class="ghost">${safeGhost}</span>` : "");
        }

        function atEnd() {
            return ta.selectionStart === ta.value.length && ta.selectionEnd === ta.value.length;
        }

        function clearGhost() {
            ghost = "";
            render();
        }

        function acceptAllGhost() {
            if (!ghost) return;
            ta.value += ghost;
            ghost = "";
            // move caret to end
            ta.selectionStart = ta.selectionEnd = ta.value.length;
            render();
        }

        function acceptOneChar() {
            if (!ghost) return;
            ta.value += ghost[0];
            ghost = ghost.slice(1);
            ta.selectionStart = ta.selectionEnd = ta.value.length;
            render();
        }

        function rejectOneChar() {
            if (!ta.value) return;
            ghost = ta.value.slice(-1) + ghost;
            ta.value = ta.value.slice(0, -1);
            ta.selectionStart = ta.selectionEnd = ta.value.length;
            render();
        }

        function getModel() {
            const custom = (customModel.value || "").trim();
            return custom || selectedModel;
        }

        function getApiKey() {
            return (apiKeyEl.value || "").trim();
        }

        function cancelInFlight() {
            if (inFlight) {
                try { inFlight.abort(); } catch (_) {}
                inFlight = null;
            }
        }

        function normalizeCompletion(prefix, completion) {
            if (!completion) return "";
            let c = completion;

            // If model echoed some of the prefix, remove overlap (simple heuristic)
            // Check if completion starts with last 50 chars of prefix (or smaller)
            const tail = prefix.slice(-50);
            if (tail && c.startsWith(tail)) c = c.slice(tail.length);

            // If it repeats the full prefix (rare), strip that too
            if (c.startsWith(prefix)) c = c.slice(prefix.length);

            // Avoid huge leading whitespace if prefix already ends with whitespace
            if (/\s$/.test(prefix)) c = c.replace(/^\s+/, "");

            return c;
        }

        function extractOutputText(json) {
            // The REST response often contains output items with {content:[{type:"output_text", text:"..."}]}
            // We'll extract concatenated output_text blocks.
            if (!json) return "";
            if (typeof json.output_text === "string") return json.output_text;

            const out = json.output;
            if (!Array.isArray(out)) return "";

            let acc = "";
            for (const item of out) {
                if (!item || item.type !== "message") continue;
                const content = item.content;
                if (!Array.isArray(content)) continue;
                for (const c of content) {
                    if (c && c.type === "output_text" && typeof c.text === "string") acc += c.text;
                }
            }
            return acc;
        }

        // ====== API call ======
        async function requestCompletion(prefix) {
            const apiKey = getApiKey();
            if (!apiKey) {
                setStatus("bad", "missing_api_key");
                return "";
            }

            // Keep only the tail as context (demo)
            const context = prefix.slice(-MAX_CONTEXT_CHARS);

            const instructions =
`あなたがやること：
- 入力されたテキストの「続き」だけを自然に補完する
- 既存の文章は絶対に繰り返さない（出力に含めない）
- 可能なら1〜2文程度で止める（短め）
- 余計な解説はしない（続きの本文のみ）`;

            const body = {
                model: getModel(),
                instructions,
                input: context,
                max_output_tokens: MAX_OUTPUT_TOKENS,
                temperature: TEMPERATURE,
                // store false would be nicer for privacy; but keeping default behavior is okay for demo.
                // store: false,
            };

            if (DEBUG_CONSOLE) {
                logGroup("[OpenAI Request]", {
                    url: "https://api.openai.com/v1/responses",
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json",
                        "Authorization": "Bearer " + maskApiKey(apiKey) // 伏せる
                    },
                    body: {
                        ...body,
                        // 入力だけ長くなりがちなのでログはトリム
                        input: trimForLog(body.input)
                    }
                });
            }


            cancelInFlight();
            inFlight = new AbortController();

            setStatus("busy", "requesting...");
            const res = await fetch("https://api.openai.com/v1/responses", {
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "Authorization": "Bearer " + apiKey
                },
                body: JSON.stringify(body),
                signal: inFlight.signal
            });

            if (!res.ok) {
                let msg = "http_" + res.status;
                try {
                    const err = await res.json();
                    msg = (err && err.error && err.error.message) ? err.error.message : msg;
                    if (DEBUG_CONSOLE) {
                        logGroup("[OpenAI Error]", {
                            http_status: res.status,
                            message: msg
                        });
                    }
                } catch (_) {}
                setStatus("bad", msg);
                return "";
            }

            const json = await res.json();
            if (DEBUG_CONSOLE) {
                const outText = extractOutputText(json);
                logGroup("[OpenAI Response]", {
                    http_status: res.status,
                    ok: res.ok,
                    output_text: trimForLog(outText),
                    ...(LOG_RESPONSE_JSON ? { raw_json: json } : {})
                });
            }

            setStatus("ok", "ok");
            const raw = extractOutputText(json);
            return raw || "";
        }

        // ====== Debounced completion logic ======
        async function scheduleCompletion() {
            // Only show ghost when caret is at end (demo behavior)
            if (!atEnd()) { clearGhost(); return; }

            const text = ta.value || "";
            if (!text.trim()) { clearGhost(); setStatus("", "idle"); return; }

            // if user continues typing, we should wipe old ghost
            clearGhost();

            // debounce
            if (debounceTimer) clearTimeout(debounceTimer);
            debounceTimer = setTimeout(async () => {
                // Avoid firing if caret moved
                if (!atEnd()) return;

                const prefix = ta.value || "";
                lastRequestedPrefix = prefix;

                try {
                    const completion = await requestCompletion(prefix);
                    // If user changed text during the request, ignore stale result
                    if ((ta.value || "") !== lastRequestedPrefix) return;

                    const normalized = normalizeCompletion(prefix, completion);
                    ghost = normalized;
                    render();
                    if (!ghost) setStatus("ok", "ok (empty)");
                } catch (e) {
                    if (e && e.name === "AbortError") return;
                    setStatus("bad", (e && e.message) ? e.message : "error");
                }
            }, DEBOUNCE_MS);
        }

        // ====== Model tabs ======
        modelTabs.addEventListener("click", (e) => {
            const btn = e.target.closest("button[data-model]");
            if (!btn) return;
            selectedModel = btn.dataset.model;
            for (const b of modelTabs.querySelectorAll("button")) b.classList.toggle("active", b === btn);
            // Changing model invalidates ghost
            clearGhost();
            scheduleCompletion();
        });

        // ====== Key storage (requested: Web Storage) ======
        function loadKeyFromStorage() {
            try {
                const saved = localStorage.getItem(STORAGE_KEY);
                if (saved) apiKeyEl.value = saved;
            } catch (_) {}
        }
        function saveKeyToStorage() {
            try {
                localStorage.setItem(STORAGE_KEY, getApiKey());
                setStatus("ok", "key_saved");
            } catch (e) {
                setStatus("bad", "storage_failed");
            }
        }
        function clearKeyFromStorage() {
            try {
                localStorage.removeItem(STORAGE_KEY);
                apiKeyEl.value = "";
                setStatus("", "key_cleared");
            } catch (_) {}
        }
        saveKeyBtn.addEventListener("click", saveKeyToStorage);
        clearKeyBtn.addEventListener("click", clearKeyFromStorage);
        apiKeyEl.addEventListener("keydown", (e) => {
            if (e.key === "Enter") saveKeyToStorage();
        });

        // ====== Editor events ======
        ta.addEventListener("input", () => {
            // any edit cancels in-flight and schedules a new completion
            cancelInFlight();
            scheduleCompletion();
            render();
        });

        ta.addEventListener("scroll", () => {
            mirrorEl.scrollTop = ta.scrollTop;
            mirrorEl.scrollLeft = ta.scrollLeft;
        });

        ta.addEventListener("click", () => {
            // if user clicks away from end, drop suggestion
            if (!atEnd()) clearGhost();
        });

        ta.addEventListener("keyup", () => {
            // moving caret with mouse/keys should drop suggestion unless at end
            if (!atEnd()) clearGhost();
        });

        ta.addEventListener("keydown", (e) => {
            // Behavior requirements:
            // - Tab: accept ghost entirely
            // - ArrowRight: accept 1 char
            // - ArrowLeft: reject 1 char (move back to ghost)
            // - Enter: delete ghost
            if (!ghost) return;

            // Only when caret is at end (otherwise it gets weird fast)
            if (!atEnd()) return;

            if (e.key === "Tab") {
                e.preventDefault();
                acceptAllGhost();
                return;
            }
            if (e.key === "ArrowRight") {
                e.preventDefault();
                acceptOneChar();
                return;
            }
            if (e.key === "ArrowLeft") {
                e.preventDefault();
                rejectOneChar();
                return;
            }
            if (e.key === "Enter") {
                e.preventDefault();
                clearGhost();
                setStatus("", "ghost_cleared");
                return;
            }
            if (e.key === "Escape") {
                e.preventDefault();
                clearGhost();
                setStatus("", "ghost_cleared");
                return;
            }
        });

        // ====== Init ======
        loadKeyFromStorage();
        render();
        setStatus("", "idle");
    </script>
</body>
</html>
