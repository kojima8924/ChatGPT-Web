<!doctype html>
<html lang="ja">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Text Autocomplete Demo (OpenAI API)</title>
    <style>
        :root {
            --bg: #0b0f19;
            --panel: #111827;
            --panel2: #0f172a;
            --border: rgba(255,255,255,.12);
            --text: rgba(255,255,255,.92);
            --muted: rgba(255,255,255,.68);
            --ghost: rgba(255,255,255,.35);
            --accent: #60a5fa;
            --danger: #fb7185;
            --ok: #34d399;
            --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
            --sans: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Hiragino Kaku Gothic ProN", "Noto Sans JP", "Yu Gothic", "Meiryo", sans-serif;
        }
        html, body { height: 100%; }
        body {
            margin: 0;
            font-family: var(--sans);
            background: radial-gradient(1200px 600px at 30% -10%, #1f2a5a 0%, transparent 60%),
                        radial-gradient(800px 500px at 80% 0%, #10304a 0%, transparent 55%),
                        var(--bg);
            color: var(--text);
        }
        .wrap {
            max-width: 980px;
            margin: 22px auto 40px;
            padding: 0 16px;
        }
        h1 {
            font-size: 18px;
            margin: 0 0 14px;
            font-weight: 700;
            letter-spacing: .2px;
        }
        .card {
            border: 1px solid var(--border);
            background: linear-gradient(180deg, rgba(17,24,39,.92), rgba(15,23,42,.92));
            border-radius: 14px;
            box-shadow: 0 20px 60px rgba(0,0,0,.35);
            overflow: hidden;
            margin-bottom: 14px;
        }
        .card .head {
            padding: 14px 14px 10px;
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            gap: 10px;
            justify-content: space-between;
            flex-wrap: wrap;
        }
        .left, .right {
            display: flex;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap;
        }
        .label {
            font-size: 12px;
            color: var(--muted);
        }
        .seg {
            display: inline-flex;
            border: 1px solid var(--border);
            border-radius: 999px;
            overflow: hidden;
            background: rgba(255,255,255,.04);
        }
        .seg button {
            appearance: none;
            border: 0;
            padding: 8px 10px;
            cursor: pointer;
            color: var(--muted);
            background: transparent;
            font-size: 12px;
            font-family: var(--mono);
        }
        .seg button.active {
            background: rgba(96,165,250,.18);
            color: rgba(255,255,255,.95);
        }
        .seg button:hover { background: rgba(255,255,255,.06); }

        input[type="password"], input[type="text"], input[type="number"] {
            border: 1px solid var(--border);
            background: rgba(0,0,0,.18);
            color: rgba(255,255,255,.92);
            padding: 9px 10px;
            border-radius: 10px;
            outline: none;
            font-size: 12px;
            font-family: var(--mono);
            width: min(380px, 70vw);
        }
        input[type="number"] {
            width: 80px;
        }
        input[type="range"] {
            width: 120px;
            accent-color: var(--accent);
        }
        .mini {
            width: 200px;
        }
        .btn {
            border: 1px solid var(--border);
            background: rgba(255,255,255,.06);
            color: rgba(255,255,255,.9);
            padding: 9px 10px;
            border-radius: 10px;
            cursor: pointer;
            font-size: 12px;
        }
        .btn:hover { background: rgba(255,255,255,.09); }
        .btn.danger:hover { background: rgba(251,113,133,.14); border-color: rgba(251,113,133,.3); }
        .btn.primary { background: rgba(96,165,250,.2); border-color: rgba(96,165,250,.3); }
        .btn.primary:hover { background: rgba(96,165,250,.3); }
        .status {
            font-size: 12px;
            color: var(--muted);
            font-family: var(--mono);
        }
        .dot { display: inline-block; width: 8px; height: 8px; border-radius: 99px; margin-right: 8px; vertical-align: -1px; background: rgba(255,255,255,.25); }
        .dot.ok { background: rgba(52,211,153,.9); }
        .dot.bad { background: rgba(251,113,133,.95); }
        .dot.busy { background: rgba(96,165,250,.95); }

        .editor {
            position: relative;
            padding: 14px;
        }
        .editorShell{
            position: relative;
            border: 1px solid var(--border);
            background: rgba(0,0,0,.14);
            border-radius: 14px;
            overflow: hidden;
            min-height: 320px;
        }
        /* Mirror layer (shows typed + ghost) */
        pre#mirror {
            margin: 0;
            padding: 14px;
            min-height: 320px;
            white-space: pre-wrap;
            word-wrap: break-word;
            font-family: var(--mono);
            font-size: 14px;
            line-height: 1.6;
            color: rgba(255,255,255,.92);
            pointer-events: none;
        }
        #mirror .ghost { color: var(--ghost); }

        /* Real textarea layer (transparent text, caret visible) */
        textarea#ta {
            position: absolute;
            inset: 0;
            resize: none;
            border: 0;
            outline: none;
            padding: 14px;
            width: 100%;
            height: 100%;
            background: transparent;
            color: transparent;          /* important: mirror displays text */
            caret-color: rgba(255,255,255,.92);
            font-family: var(--mono);
            font-size: 14px;
            line-height: 1.6;
        }
        /* selection still works but text is transparent; this is demo-friendly */
        textarea#ta::selection { background: rgba(96,165,250,.35); }

        .foot {
            padding: 14px 14px 16px;
            border-top: 1px solid var(--border);
            background: rgba(255,255,255,.02);
            color: var(--muted);
            font-size: 13px;
            line-height: 1.7;
        }
        .foot kbd{
            font-family: var(--mono);
            font-size: 12px;
            border: 1px solid var(--border);
            background: rgba(255,255,255,.06);
            border-bottom-color: rgba(255,255,255,.12);
            padding: 2px 6px;
            border-radius: 8px;
            color: rgba(255,255,255,.86);
        }
        .small {
            font-size: 12px;
            color: var(--muted);
        }
        a { color: rgba(96,165,250,.95); }

        /* Settings Panel */
        .settings-toggle {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
            padding: 10px 14px;
            border-bottom: 1px solid var(--border);
            background: rgba(255,255,255,.02);
            user-select: none;
        }
        .settings-toggle:hover {
            background: rgba(255,255,255,.04);
        }
        .settings-toggle .arrow {
            transition: transform 0.2s;
            font-size: 10px;
        }
        .settings-toggle.open .arrow {
            transform: rotate(90deg);
        }
        .settings-panel {
            display: none;
            padding: 14px;
            border-bottom: 1px solid var(--border);
            background: rgba(0,0,0,.1);
        }
        .settings-panel.open {
            display: block;
        }
        .settings-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 16px;
        }
        .setting-item {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }
        .setting-item .label {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .setting-item .value-display {
            font-family: var(--mono);
            font-size: 11px;
            color: var(--accent);
            background: rgba(96,165,250,.1);
            padding: 2px 6px;
            border-radius: 4px;
        }
        .setting-item textarea {
            border: 1px solid var(--border);
            background: rgba(0,0,0,.18);
            color: rgba(255,255,255,.92);
            padding: 10px;
            border-radius: 10px;
            outline: none;
            font-size: 12px;
            font-family: var(--mono);
            resize: vertical;
            min-height: 80px;
            width: 100%;
            box-sizing: border-box;
        }
        .setting-row {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .settings-actions {
            margin-top: 14px;
            display: flex;
            gap: 10px;
        }
        .prompt-full {
            grid-column: 1 / -1;
        }
    </style>
</head>
<body>
    <div class="wrap">
        <h1>Text Autocomplete Demo (front-only / single file)</h1>

        <!-- Top: model tabs + API key -->
        <div class="card">
            <div class="head">
                <div class="left">
                    <div>
                        <div class="label">Model (tabs)</div>
                        <div class="seg" id="modelTabs" role="tablist" aria-label="Model tabs">
                            <button type="button" class="active" data-model="gpt-4o-mini">gpt-4o-mini</button>
                            <button type="button" data-model="gpt-4.1-mini">gpt-4.1-mini</button>
                            <button type="button" data-model="gpt-5-mini">gpt-5-mini</button>
                            <button type="button" data-model="gpt-5.2">gpt-5.2</button>
                        </div>
                    </div>
                    <div>
                        <div class="label">Custom model (optional)</div>
                        <input id="customModel" class="mini" type="text" placeholder="e.g. gpt-4o" spellcheck="false" />
                    </div>
                </div>

                <div class="right">
                    <div>
                        <div class="label">OpenAI API Key (saved to Web Storage)</div>
                        <input id="apiKey" type="password" placeholder="sk-..." autocomplete="off" spellcheck="false" />
                    </div>
                    <button class="btn" id="saveKeyBtn" type="button">Save</button>
                    <button class="btn danger" id="clearKeyBtn" type="button">Clear</button>
                    <div class="status" id="status"><span class="dot"></span>idle</div>
                </div>
            </div>

            <!-- Settings Panel -->
            <div class="settings-toggle" id="settingsToggle">
                <span class="arrow">▶</span>
                <span>設定</span>
            </div>
            <div class="settings-panel" id="settingsPanel">
                <div class="settings-grid">
                    <div class="setting-item">
                        <div class="label">
                            待機時間 (ms)
                            <span class="value-display" id="debounceDisplay">700</span>
                        </div>
                        <div class="setting-row">
                            <input type="range" id="debounceRange" min="100" max="2000" step="100" value="700" />
                            <input type="number" id="debounceInput" min="100" max="5000" step="50" value="700" />
                        </div>
                    </div>
                    <div class="setting-item">
                        <div class="label">
                            Temperature
                            <span class="value-display" id="temperatureDisplay">0.7</span>
                        </div>
                        <div class="setting-row">
                            <input type="range" id="temperatureRange" min="0" max="2" step="0.1" value="0.7" />
                            <input type="number" id="temperatureInput" min="0" max="2" step="0.1" value="0.7" />
                        </div>
                    </div>
                    <div class="setting-item">
                        <div class="label">
                            Max Output Tokens
                            <span class="value-display" id="maxTokensDisplay">96</span>
                        </div>
                        <div class="setting-row">
                            <input type="range" id="maxTokensRange" min="16" max="512" step="16" value="96" />
                            <input type="number" id="maxTokensInput" min="1" max="4096" step="1" value="96" />
                        </div>
                    </div>
                    <div class="setting-item">
                        <div class="label">
                            Max Context Chars
                            <span class="value-display" id="maxContextDisplay">2000</span>
                        </div>
                        <div class="setting-row">
                            <input type="range" id="maxContextRange" min="500" max="10000" step="500" value="2000" />
                            <input type="number" id="maxContextInput" min="100" max="50000" step="100" value="2000" />
                        </div>
                    </div>
                    <div class="setting-item prompt-full">
                        <div class="label">システムプロンプト</div>
                        <textarea id="systemPrompt" rows="5">あなたがやること：
- 入力されたテキストの「続き」だけを自然に補完する
- 既存の文章は絶対に繰り返さない（出力に含めない）
- 可能なら1〜2文程度で止める（短め）
- 余計な解説はしない（続きの本文のみ）</textarea>
                    </div>
                </div>
                <div class="settings-actions">
                    <button class="btn primary" id="saveSettingsBtn" type="button">設定を保存</button>
                    <button class="btn" id="resetSettingsBtn" type="button">デフォルトに戻す</button>
                </div>
            </div>

            <!-- Middle: text input with ghost completion -->
            <div class="editor">
                <div class="editorShell" aria-label="Editor">
                    <pre id="mirror"></pre>
                    <textarea id="ta" spellcheck="false" aria-label="Text input"></textarea>
                </div>
                <div class="small" style="margin-top:10px;">
                    ※「入力文字はミラー層に描画、textareaの文字色は透明（カーソルだけ表示）」方式です。
                </div>
            </div>

            <!-- Bottom: usage -->
            <div class="foot">
                <div><strong>使い方</strong></div>
                <ul style="margin:8px 0 0; padding-left: 18px;">
                    <li>テキスト欄の入力が <kbd id="debounceHint">700ms</kbd> 止まると、続きが <span style="color:var(--ghost);">灰色</span> で表示されます。</li>
                    <li><kbd>Tab</kbd>：灰色部分を全部確定（追記）</li>
                    <li><kbd>→</kbd>：灰色部分を1文字確定 / <kbd>←</kbd>：1文字戻す（カーソルが末尾にあるときのみ）</li>
                    <li><kbd>Enter</kbd>：灰色部分を削除（提案を破棄）※提案が無いときは普通に改行</li>
                    <li><kbd>Esc</kbd>：灰色部分を削除（提案を破棄）</li>
                </ul>
            </div>
        </div>
    </div>

    <script>
        // ====== Default Settings ======
        const DEFAULTS = {
            debounceMs: 700,
            maxContextChars: 2000,
            maxOutputTokens: 96,
            temperature: 0.7,
            systemPrompt: `あなたがやること：
- 入力されたテキストの「続き」だけを自然に補完する
- 既存の文章は絶対に繰り返さない（出力に含めない）
- 可能なら1〜2文程度で止める（短め）
- 余計な解説はしない（続きの本文のみ）`
        };

        const STORAGE_KEY = "demo_openai_api_key_v1";
        const SETTINGS_KEY = "demo_openai_settings_v1";
        const DEBUG_CONSOLE = true;
        const LOG_TRIM = 800;
        const LOG_RESPONSE_JSON = false;

        // ====== Settings State ======
        let settings = { ...DEFAULTS };

        // ====== DOM ======
        const modelTabs = document.getElementById("modelTabs");
        const customModel = document.getElementById("customModel");
        const apiKeyEl = document.getElementById("apiKey");
        const saveKeyBtn = document.getElementById("saveKeyBtn");
        const clearKeyBtn = document.getElementById("clearKeyBtn");
        const statusEl = document.getElementById("status");
        const mirrorEl = document.getElementById("mirror");
        const ta = document.getElementById("ta");

        // Settings DOM
        const settingsToggle = document.getElementById("settingsToggle");
        const settingsPanel = document.getElementById("settingsPanel");
        const debounceRange = document.getElementById("debounceRange");
        const debounceInput = document.getElementById("debounceInput");
        const debounceDisplay = document.getElementById("debounceDisplay");
        const debounceHint = document.getElementById("debounceHint");
        const temperatureRange = document.getElementById("temperatureRange");
        const temperatureInput = document.getElementById("temperatureInput");
        const temperatureDisplay = document.getElementById("temperatureDisplay");
        const maxTokensRange = document.getElementById("maxTokensRange");
        const maxTokensInput = document.getElementById("maxTokensInput");
        const maxTokensDisplay = document.getElementById("maxTokensDisplay");
        const maxContextRange = document.getElementById("maxContextRange");
        const maxContextInput = document.getElementById("maxContextInput");
        const maxContextDisplay = document.getElementById("maxContextDisplay");
        const systemPrompt = document.getElementById("systemPrompt");
        const saveSettingsBtn = document.getElementById("saveSettingsBtn");
        const resetSettingsBtn = document.getElementById("resetSettingsBtn");

        // ====== State ======
        let selectedModel = "gpt-4o-mini";
        let ghost = "";
        let debounceTimer = null;
        let inFlight = null;
        let lastRequestedPrefix = "";

        // ====== Settings Functions ======
        function loadSettings() {
            try {
                const saved = localStorage.getItem(SETTINGS_KEY);
                if (saved) {
                    const parsed = JSON.parse(saved);
                    settings = { ...DEFAULTS, ...parsed };
                }
            } catch (_) {}
            applySettingsToUI();
        }

        function saveSettings() {
            try {
                localStorage.setItem(SETTINGS_KEY, JSON.stringify(settings));
                setStatus("ok", "settings_saved");
            } catch (e) {
                setStatus("bad", "save_failed");
            }
        }

        function resetSettings() {
            settings = { ...DEFAULTS };
            applySettingsToUI();
            saveSettings();
            setStatus("ok", "settings_reset");
        }

        function applySettingsToUI() {
            debounceRange.value = settings.debounceMs;
            debounceInput.value = settings.debounceMs;
            debounceDisplay.textContent = settings.debounceMs;
            debounceHint.textContent = settings.debounceMs + "ms";

            temperatureRange.value = settings.temperature;
            temperatureInput.value = settings.temperature;
            temperatureDisplay.textContent = settings.temperature;

            maxTokensRange.value = settings.maxOutputTokens;
            maxTokensInput.value = settings.maxOutputTokens;
            maxTokensDisplay.textContent = settings.maxOutputTokens;

            maxContextRange.value = settings.maxContextChars;
            maxContextInput.value = settings.maxContextChars;
            maxContextDisplay.textContent = settings.maxContextChars;

            systemPrompt.value = settings.systemPrompt;
        }

        function readSettingsFromUI() {
            settings.debounceMs = parseInt(debounceInput.value) || DEFAULTS.debounceMs;
            settings.temperature = parseFloat(temperatureInput.value) || DEFAULTS.temperature;
            settings.maxOutputTokens = parseInt(maxTokensInput.value) || DEFAULTS.maxOutputTokens;
            settings.maxContextChars = parseInt(maxContextInput.value) || DEFAULTS.maxContextChars;
            settings.systemPrompt = systemPrompt.value || DEFAULTS.systemPrompt;
        }

        // Setting sync helpers
        function syncSetting(rangeEl, inputEl, displayEl, key, parser, extraUpdate) {
            const update = (val) => {
                const parsed = parser(val);
                settings[key] = parsed;
                rangeEl.value = parsed;
                inputEl.value = parsed;
                displayEl.textContent = parsed;
                if (extraUpdate) extraUpdate(parsed);
            };
            rangeEl.addEventListener("input", () => update(rangeEl.value));
            inputEl.addEventListener("input", () => update(inputEl.value));
            inputEl.addEventListener("change", () => update(inputEl.value));
        }

        // ====== Helpers ======
        function maskApiKey(k) {
            if (!k) return "";
            const head = k.slice(0, 4);
            return head + "…" + "*".repeat(Math.max(0, k.length - 5));
        }

        function trimForLog(s, n = LOG_TRIM) {
            if (typeof s !== "string") return s;
            if (s.length <= n) return s;
            return s.slice(0, n) + `…(trimmed ${s.length - n} chars)`;
        }

        function logGroup(title, obj) {
            if (!DEBUG_CONSOLE) return;
            console.groupCollapsed(title);
            try { console.log(obj); } finally { console.groupEnd(); }
        }

        function setStatus(kind, text) {
            const dot = statusEl.querySelector(".dot");
            dot.className = "dot" + (kind ? (" " + kind) : "");
            statusEl.lastChild && statusEl.lastChild.remove();
            statusEl.appendChild(document.createTextNode(text));
        }

        function escapeHtml(s) {
            return s.replace(/[&<>"']/g, (c) => (
                c === "&" ? "&amp;" :
                c === "<" ? "&lt;" :
                c === ">" ? "&gt;" :
                c === '"' ? "&quot;" : "&#39;"
            ));
        }

        function render() {
            const text = ta.value || "";
            const safeText = escapeHtml(text).replace(/\n$/g, "\n\u200b");
            const safeGhost = escapeHtml(ghost);
            mirrorEl.innerHTML = safeText + (ghost ? `<span class="ghost">${safeGhost}</span>` : "");
        }

        function atEnd() {
            return ta.selectionStart === ta.value.length && ta.selectionEnd === ta.value.length;
        }

        function clearGhost() {
            ghost = "";
            render();
        }

        function acceptAllGhost() {
            if (!ghost) return;
            ta.value += ghost;
            ghost = "";
            ta.selectionStart = ta.selectionEnd = ta.value.length;
            render();
        }

        function acceptOneChar() {
            if (!ghost) return;
            ta.value += ghost[0];
            ghost = ghost.slice(1);
            ta.selectionStart = ta.selectionEnd = ta.value.length;
            render();
        }

        function rejectOneChar() {
            if (!ta.value) return;
            ghost = ta.value.slice(-1) + ghost;
            ta.value = ta.value.slice(0, -1);
            ta.selectionStart = ta.selectionEnd = ta.value.length;
            render();
        }

        function getModel() {
            const custom = (customModel.value || "").trim();
            return custom || selectedModel;
        }

        function getApiKey() {
            return (apiKeyEl.value || "").trim();
        }

        function cancelInFlight() {
            if (inFlight) {
                try { inFlight.abort(); } catch (_) {}
                inFlight = null;
            }
        }

        function normalizeCompletion(prefix, completion) {
            if (!completion) return "";
            let c = completion;

            const tail = prefix.slice(-50);
            if (tail && c.startsWith(tail)) c = c.slice(tail.length);
            if (c.startsWith(prefix)) c = c.slice(prefix.length);
            if (/\s$/.test(prefix)) c = c.replace(/^\s+/, "");

            return c;
        }

        function extractOutputText(json) {
            if (!json) return "";
            if (typeof json.output_text === "string") return json.output_text;

            const out = json.output;
            if (!Array.isArray(out)) return "";

            let acc = "";
            for (const item of out) {
                if (!item || item.type !== "message") continue;
                const content = item.content;
                if (!Array.isArray(content)) continue;
                for (const c of content) {
                    if (c && c.type === "output_text" && typeof c.text === "string") acc += c.text;
                }
            }
            return acc;
        }

        // ====== API call ======
        async function requestCompletion(prefix) {
            const apiKey = getApiKey();
            if (!apiKey) {
                setStatus("bad", "missing_api_key");
                return "";
            }

            const context = prefix.slice(-settings.maxContextChars);

            const body = {
                model: getModel(),
                instructions: settings.systemPrompt,
                input: context,
                max_output_tokens: settings.maxOutputTokens,
                temperature: settings.temperature,
            };

            if (DEBUG_CONSOLE) {
                logGroup("[OpenAI Request]", {
                    url: "https://api.openai.com/v1/responses",
                    method: "POST",
                    headers: {
                        "Content-Type": "application/json",
                        "Authorization": "Bearer " + maskApiKey(apiKey)
                    },
                    body: {
                        ...body,
                        input: trimForLog(body.input)
                    }
                });
            }

            cancelInFlight();
            inFlight = new AbortController();

            setStatus("busy", "requesting...");
            const res = await fetch("https://api.openai.com/v1/responses", {
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    "Authorization": "Bearer " + apiKey
                },
                body: JSON.stringify(body),
                signal: inFlight.signal
            });

            if (!res.ok) {
                let msg = "http_" + res.status;
                try {
                    const err = await res.json();
                    msg = (err && err.error && err.error.message) ? err.error.message : msg;
                    if (DEBUG_CONSOLE) {
                        logGroup("[OpenAI Error]", {
                            http_status: res.status,
                            message: msg
                        });
                    }
                } catch (_) {}
                setStatus("bad", msg);
                return "";
            }

            const json = await res.json();
            if (DEBUG_CONSOLE) {
                const outText = extractOutputText(json);
                logGroup("[OpenAI Response]", {
                    http_status: res.status,
                    ok: res.ok,
                    output_text: trimForLog(outText),
                    ...(LOG_RESPONSE_JSON ? { raw_json: json } : {})
                });
            }

            setStatus("ok", "ok");
            const raw = extractOutputText(json);
            return raw || "";
        }

        // ====== Debounced completion logic ======
        async function scheduleCompletion() {
            if (!atEnd()) { clearGhost(); return; }

            const text = ta.value || "";
            if (!text.trim()) { clearGhost(); setStatus("", "idle"); return; }

            clearGhost();

            if (debounceTimer) clearTimeout(debounceTimer);
            debounceTimer = setTimeout(async () => {
                if (!atEnd()) return;

                const prefix = ta.value || "";
                lastRequestedPrefix = prefix;

                try {
                    const completion = await requestCompletion(prefix);
                    if ((ta.value || "") !== lastRequestedPrefix) return;

                    const normalized = normalizeCompletion(prefix, completion);
                    ghost = normalized;
                    render();
                    if (!ghost) setStatus("ok", "ok (empty)");
                } catch (e) {
                    if (e && e.name === "AbortError") return;
                    setStatus("bad", (e && e.message) ? e.message : "error");
                }
            }, settings.debounceMs);
        }

        // ====== Model tabs ======
        modelTabs.addEventListener("click", (e) => {
            const btn = e.target.closest("button[data-model]");
            if (!btn) return;
            selectedModel = btn.dataset.model;
            for (const b of modelTabs.querySelectorAll("button")) b.classList.toggle("active", b === btn);
            clearGhost();
            scheduleCompletion();
        });

        // ====== Settings toggle ======
        settingsToggle.addEventListener("click", () => {
            settingsToggle.classList.toggle("open");
            settingsPanel.classList.toggle("open");
        });

        // ====== Settings sync ======
        syncSetting(debounceRange, debounceInput, debounceDisplay, "debounceMs", parseInt, (v) => {
            debounceHint.textContent = v + "ms";
        });
        syncSetting(temperatureRange, temperatureInput, temperatureDisplay, "temperature", parseFloat);
        syncSetting(maxTokensRange, maxTokensInput, maxTokensDisplay, "maxOutputTokens", parseInt);
        syncSetting(maxContextRange, maxContextInput, maxContextDisplay, "maxContextChars", parseInt);

        systemPrompt.addEventListener("input", () => {
            settings.systemPrompt = systemPrompt.value;
        });

        saveSettingsBtn.addEventListener("click", () => {
            readSettingsFromUI();
            saveSettings();
        });

        resetSettingsBtn.addEventListener("click", resetSettings);

        // ====== Key storage ======
        function loadKeyFromStorage() {
            try {
                const saved = localStorage.getItem(STORAGE_KEY);
                if (saved) apiKeyEl.value = saved;
            } catch (_) {}
        }
        function saveKeyToStorage() {
            try {
                localStorage.setItem(STORAGE_KEY, getApiKey());
                setStatus("ok", "key_saved");
            } catch (e) {
                setStatus("bad", "storage_failed");
            }
        }
        function clearKeyFromStorage() {
            try {
                localStorage.removeItem(STORAGE_KEY);
                apiKeyEl.value = "";
                setStatus("", "key_cleared");
            } catch (_) {}
        }
        saveKeyBtn.addEventListener("click", saveKeyToStorage);
        clearKeyBtn.addEventListener("click", clearKeyFromStorage);
        apiKeyEl.addEventListener("keydown", (e) => {
            if (e.key === "Enter") saveKeyToStorage();
        });

        // ====== Editor events ======
        ta.addEventListener("input", () => {
            cancelInFlight();
            scheduleCompletion();
            render();
        });

        ta.addEventListener("scroll", () => {
            mirrorEl.scrollTop = ta.scrollTop;
            mirrorEl.scrollLeft = ta.scrollLeft;
        });

        ta.addEventListener("click", () => {
            if (!atEnd()) clearGhost();
        });

        ta.addEventListener("keyup", () => {
            if (!atEnd()) clearGhost();
        });

        ta.addEventListener("keydown", (e) => {
            if (!ghost) return;
            if (!atEnd()) return;

            if (e.key === "Tab") {
                e.preventDefault();
                acceptAllGhost();
                return;
            }
            if (e.key === "ArrowRight") {
                e.preventDefault();
                acceptOneChar();
                return;
            }
            if (e.key === "ArrowLeft") {
                e.preventDefault();
                rejectOneChar();
                return;
            }
            if (e.key === "Enter") {
                e.preventDefault();
                clearGhost();
                setStatus("", "ghost_cleared");
                return;
            }
            if (e.key === "Escape") {
                e.preventDefault();
                clearGhost();
                setStatus("", "ghost_cleared");
                return;
            }
        });

        // ====== Init ======
        loadSettings();
        loadKeyFromStorage();
        render();
        setStatus("", "idle");
    </script>
</body>
</html>
